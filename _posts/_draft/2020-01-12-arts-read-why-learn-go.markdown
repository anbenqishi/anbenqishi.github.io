---
layout: post
title:【阅读】为什么学习go
published: true
categories: ARTS go
tags: ARTS go
---

## 原文

[Why should you learn Go?](https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65)

## ## 概述

1. 过去几年，一颗新星正冉冉升起，他就是**go**语言。没有比一门新语言更令开发者高潮的吧？（不接受反驳）所以呢，作者就学了4到5个月就开始要吹**go**了，且看他如何吹（我也是边看边敲的）。
2. 本文主旨是解释当前的计算机软硬件处于哪个发展阶段，以及为啥我们需要一门向**go**这般的新语言。如果没有问题，也就不存在什么解决办法是不是。注意，这里不是教`hello, world!`的。

### 硬件限制

1. 摩尔定律在凋零。2004年，Intel 推出奔腾4处理器，3.0GHz的时钟频率。现在，俺的MBP2016的时钟频率是2.9GHz。所以呢，一个十年过去（这篇文章是2017年写的），处理性能几乎没啥变化（四舍五入，忽略不计）。

   ![img](../images/posts/go/1_Azz7YwzYYR6lDKFj8iIGZg.png)

   2. 看看上面这张图，单线程性能，时钟频率，在过去十年几乎是稳定的。如果你想多塞点晶体管进去看能不能提高性能，那你就错了。你要问我为什么，我也说不清，无非是在那个量级上，量子相关属性开始有影响（量子隧道？），再多塞点晶体管已经越来越不容易了，代价越来越大，性价比不高了。
   3. 当前的解决方案是：厂商给处理器多加核心，四核八核都已经很常见了；引入超线程；引入跟多的缓存增加性能。
   4. 每个解决方案也有自己的局限性。缓存也有它的物理限制----越大的缓存，获取数据也越慢。多核也有代价，而且也不能无限增加啊。多核处理器可以同时跑多线程，这就带来了并发的问题了。后面再说。
   5. 既然不能依赖硬件的改进，剩下唯一的办法就是软件更高效。可惜，当代编程语言并不是那么有效率。

   ### Go有goroutines!!

   1. 多核在不远将来的趋势是核心数的进一步增加；当今的应用也使用了很多微服务来维护数据库连接，消息队列以及缓存等。所以软件还有编程语言应该更容易支持并发，并且随着核心数的增加可扩展。
   2. 现在很多语言（如Java，Python等）都是从上世纪90年代单线程环境发展起来的。虽然很多支持多线程，但是真正的问题其实是并发执行，线程锁，竞争条件，死锁等。这么些个令人头疼的问题，让创建多线程的应用很麻烦，尤其在这些语言上。
   3. 想想吧，在Java上创建一个线程并不能有效利用内存。每个线程都要在堆上消耗大约1MB，几千个线程的话，堆的压力那是很大的，很容易内存不足。线程间的通信也挺麻烦的。
   4. 来来来，看看2009年发布的**go**。这时的多核都很常见了，Go创建时就是时时把并发问题放在心上的。它用goroutines，而不是线程。每个goroutine几乎只消耗2KB，所以百万goroutines都不在话下。
   5. 

